import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
<<<<<<< HEAD
=======
import 'package:shared_preferences/shared_preferences.dart';
import 'package:http/http.dart' as http;
>>>>>>> origin/main
import '../models/user.dart';
import 'auth_exception.dart';
import 'api_service.dart';
// Feature flags not used here

abstract class AuthServiceInterface {
  Future<User?> signUpWithEmail({
    required String email,
    required String password,
    String? username,
    String? firstName,
    String? lastName,
    String? phoneNumber,
    String? preferredLanguage,
  });

  Future<User?> signUpWithPhone({
    required String phoneNumber,
    String? email,
    String? username,
    String? firstName,
    String? lastName,
    String? password,
    String? preferredLanguage,
  });

  Future<bool> verifyEmailOTP({required String email, required String otp});

  Future<bool> verifyPhoneOTP({required String phoneNumber, required String otp});

  Future<bool> resendEmailOTP({required String email});

  Future<bool> resendPhoneOTP({required String phoneNumber});

  Future<User?> updateUserProfile({
    required String userId,
    String? firstName,
    String? lastName,
    DateTime? dateOfBirth,
    String? gender,
    String? profileImagePath,
    String? preferredLanguage,
  });

  Future<User> signIn({required String email, required String password});

  Future<void> signOut();

  Future<User?> getCurrentUser();

  Stream<User?> authStateChanges();
}

<<<<<<< HEAD
class AuthService extends ChangeNotifier implements AuthServiceInterface {
  // Removed SharedPreferences; using in-memory storage for simplicity
  final Map<String, String> _inMemoryPrefs = {};
=======
class AuthServiceImpl extends ChangeNotifier implements AuthService {
  late SharedPreferences _prefs;
>>>>>>> origin/main
  User? _currentUser;
  final StreamController<User?> _authStateController =
      StreamController<User?>.broadcast();
  final ApiService _apiService = ApiService();

  User? get currentUser => _currentUser;

<<<<<<< HEAD
  AuthService() {
    // Minimal initialization; token will be managed by ApiService
=======
  AuthServiceImpl({String backendBaseUrl = ''}) : _backendBaseUrl = backendBaseUrl {
>>>>>>> origin/main
    _initialize();
  }

  Future<void> _initialize() async {
    // Minimal initialization; token will be managed by ApiService
    try {
      await _apiService.getStoredToken();
    } catch (_) {}
  }

  // In-memory storage helpers
  Future<void> _setString(String key, String value) async {
    _inMemoryPrefs[key] = value;
  }

  Future<String?> _getString(String key) async {
    return _inMemoryPrefs[key];
  }

  Future<void> _removeString(String key) async {
    _inMemoryPrefs.remove(key);
  }

<<<<<<< HEAD
=======
  void _loadUserFromPrefs() {
    final userJson = _prefs.getString('user');
    // Minimal in-memory AuthService used for tests and local dev.
    import 'dart:async';

    import 'package:flutter/foundation.dart';

    import '../models/user.dart';

    class AuthService with ChangeNotifier {
      final Map<String, User> _users = {};
      final Map<String, String> _passwords = {};
      final Map<String, Map<String, dynamic>> _tempRegistrations = {};

      User? _currentUser;
      final StreamController<User?> _authStateController = StreamController<User?>.broadcast();

      AuthService();

      Stream<User?> authStateChanges() => _authStateController.stream;

      Future<User?> signUpWithEmail({
        required String email,
        required String password,
        String? username,
        String? firstName,
        String? lastName,
        String? phoneNumber,
        String? preferredLanguage,
      }) async {
        if (!_isValidEmail(email)) throw Exception('Invalid email');
        if (password.length < 8) throw Exception('Password too short');

        final user = User(
          id: 'user_${_users.length + 1}',
          email: email,
          username: username,
          firstName: firstName,
          lastName: lastName,
          phoneNumber: phoneNumber,
          emailVerified: false,
          phoneVerified: false,
          preferredLanguage: preferredLanguage,
          createdAt: DateTime.now(),
        );

        _tempRegistrations[email] = {'user': user, 'password': password};
        return user;
      }

      Future<User?> signUpWithPhone({
        required String phoneNumber,
        String? email,
        String? username,
        String? firstName,
        String? lastName,
        String? password,
        String? preferredLanguage,
      }) async {
        if (!_isValidPhoneNumber(phoneNumber)) throw Exception('Invalid phone');
        if (email != null && password != null) {
          return signUpWithEmail(
            email: email,
            password: password,
            username: username,
            firstName: firstName,
            lastName: lastName,
            phoneNumber: phoneNumber,
            preferredLanguage: preferredLanguage,
          );
        }

        final user = User(
          id: 'user_${_users.length + 1}',
          phoneNumber: phoneNumber,
          email: '',
          emailVerified: false,
          phoneVerified: false,
          createdAt: DateTime.now(),
        );

        _tempRegistrations[phoneNumber] = {'user': user};
        return user;
      }

      Future<bool> verifyEmailOTP({required String email, required String otp}) async {
        final reg = _tempRegistrations[email];
        if (reg == null) throw Exception('Registration not found');

        final user = reg['user'] as User;
        final password = reg['password'] as String? ?? '';

        final verifiedUser = user.copyWith(emailVerified: true, updatedAt: DateTime.now());
        _users[email] = verifiedUser;
        if (password.isNotEmpty) _passwords[email] = password;

        _currentUser = verifiedUser;
        _authStateController.add(_currentUser);
        notifyListeners();

        _tempRegistrations.remove(email);
        return true;
      }

      Future<bool> verifyPhoneOTP({required String phoneNumber, required String otp}) async {
        final reg = _tempRegistrations[phoneNumber];
        if (reg == null) throw Exception('Registration not found');

        final user = reg['user'] as User;
        final verifiedUser = user.copyWith(phoneVerified: true, updatedAt: DateTime.now());
        final key = (verifiedUser.email != null && verifiedUser.email!.isNotEmpty)
            ? verifiedUser.email!
            : verifiedUser.phoneNumber ?? 'phone_${_users.length + 1}';
        _users[key] = verifiedUser;
        _currentUser = verifiedUser;
        _authStateController.add(_currentUser);
        notifyListeners();

        _tempRegistrations.remove(phoneNumber);
        return true;
      }

      Future<bool> resendEmailOTP({required String email}) async {
        if (!_isValidEmail(email)) throw Exception('Invalid email');
        return true;
      }

      Future<bool> resendPhoneOTP({required String phoneNumber}) async {
        if (!_isValidPhoneNumber(phoneNumber)) throw Exception('Invalid phone');
        return true;
      }

      Future<User?> updateUserProfile({
        required String userId,
        String? firstName,
        String? lastName,
        DateTime? dateOfBirth,
        String? gender,
        String? profileImagePath,
        String? preferredLanguage,
      }) async {
        if (_currentUser == null) throw Exception('No user logged in');

        final updated = _currentUser!.copyWith(
          firstName: firstName ?? _currentUser!.firstName,
          lastName: lastName ?? _currentUser!.lastName,
          dateOfBirth: dateOfBirth ?? _currentUser!.dateOfBirth,
          gender: gender ?? _currentUser!.gender,
          profileImageUrl: profileImagePath ?? _currentUser!.profileImageUrl,
          preferredLanguage: preferredLanguage ?? _currentUser!.preferredLanguage,
          updatedAt: DateTime.now(),
        );

        final key = (updated.email != null && updated.email!.isNotEmpty)
            ? updated.email!
            : updated.phoneNumber ?? updated.id;
        _users[key] = updated;
        _currentUser = updated;
        _authStateController.add(_currentUser);
        notifyListeners();
        return updated;
      }

      Future<User> signIn({required String email, required String password}) async {
        final stored = _users[email];
        if (stored == null) throw Exception('User not found');
        final storedPass = _passwords[email];
        if (storedPass == null || storedPass != password) throw Exception('Invalid credentials');

        _currentUser = stored;
        _authStateController.add(_currentUser);
        notifyListeners();
        return _currentUser!;
      }

      Future<void> signOut() async {
        _currentUser = null;
        _authStateController.add(null);
        notifyListeners();
      }

      Future<User?> getCurrentUser() async {
        return _currentUser;
      }

      bool _isValidEmail(String email) {
        final emailRegex = RegExp(r'^[^@]+@[^@]+\.[^@]+$');
        return emailRegex.hasMatch(email);
      }

      bool _isValidPhoneNumber(String phone) {
        final digitsOnly = phone.replaceAll(RegExp(r'\D'), '');
        return digitsOnly.length >= 7 && digitsOnly.length <= 15;
      }

      @override
      void dispose() {
        _authStateController.close();
        super.dispose();
      }
    }
      }

      final user = User(
        email: '',
        phoneNumber: phoneNumber,
        phoneVerified: false,
        createdAt: DateTime.now(),
      );

      // Store temporary user
      await _prefs.setString('temp_user_$phoneNumber', _jsonEncode(user.toJson()));

      // In production, send OTP via SMS
      debugPrint('Sending OTP to $phoneNumber');
      return user;
    } catch (e) {
      debugPrint('Sign up error: $e');
      rethrow;
>>>>>>> origin/main
    }

    // Since we only verify email, delegate to signUpWithEmail if email is provided
    if (email != null && password != null) {
      return signUpWithEmail(
        email: email,
        password: password,
        username: username,
        firstName: firstName,
        lastName: lastName,
        phoneNumber: phoneNumber,
        preferredLanguage: preferredLanguage,
      );
    }
    
    throw AuthException(AuthErrorCodes.invalidEmail,
      details: 'Email is required for registration');
  }

  Future<bool> verifyEmailOTP({
    required String email,
    required String otp,
  }) async {
    try {
      // Verify OTP with backend (SendGrid sends 4-digit codes)
      if (otp.length != 4) {
        debugPrint('Invalid OTP length: ${otp.length}, expected 4');
        throw AuthException(AuthErrorCodes.invalidOtpFormat);
      }

      debugPrint('Verifying OTP: $otp for email: $email');

      // Get registration data
      final registrationDataJson = await _getString('registration_data_$email');
      if (registrationDataJson == null) {
        debugPrint('No registration data found for email: $email');
        debugPrint('Available keys: ${_inMemoryPrefs.keys.toList()}');
        throw AuthException(AuthErrorCodes.userNotFound,
          details: 'Registration data not found. Please register again.');
      }

      debugPrint('Found registration data for email: $email');
      final regData = _jsonDecode(registrationDataJson);
      final verificationId = regData['verification_id'];
      
      if (verificationId == null) {
        debugPrint('No verification_id found in registration data');
        throw AuthException(AuthErrorCodes.serverError,
          details: 'Verification ID not found. Please register again.');
      }
      
      // Verify OTP with backend API
      debugPrint('Calling backend API to verify OTP with verification_id: $verificationId');
      await _apiService.verifyOtp(
        email: email, 
        otp: otp,
        verificationId: verificationId,
      );
      debugPrint('Backend verification successful');

      // Update user with verified email
      final user = User(
        email: email,
        username: regData['username'],
        firstName: regData['firstName'],
        lastName: regData['lastName'],
        phoneNumber: regData['phoneNumber'],
        emailVerified: true,
        phoneVerified: false,  // We don't verify phone numbers
        preferredLanguage: regData['preferredLanguage'],
        createdAt: DateTime.now(),
      );

      // Save verified user
      await _saveUserToPrefs(user);
      await _removeString('registration_data_$email');

      return true;
    } on ApiException catch (e) {
      debugPrint('API OTP verification error: ${e.message} (Status: ${e.statusCode})');
      if (e.statusCode == 400 || e.message.toLowerCase().contains('invalid')) {
        throw AuthException(AuthErrorCodes.invalidOtpFormat,
          details: 'Invalid OTP code. Please check and try again.');
      } else if (e.statusCode == 404) {
        throw AuthException(AuthErrorCodes.userNotFound,
          details: 'User not found. Please register again.');
      } else {
        throw AuthException(AuthErrorCodes.serverError,
          details: 'Server error: ${e.message}');
      }
    } catch (e) {
      debugPrint('Unexpected OTP verification error: $e');
      rethrow;
    }
  }

  Future<bool> verifyPhoneOTP({
    required String phoneNumber,
    required String otp,
  }) async {
    // Since we only verify email, find the email associated with this phone number
    // and call verifyEmailOTP instead
    try {
      String? foundEmail;
      
      final allKeys = _inMemoryPrefs.keys;
      for (final key in allKeys) {
        if (key.startsWith('registration_data_')) {
          final dataJson = _inMemoryPrefs[key];
          if (dataJson != null) {
            try {
              final data = _jsonDecode(dataJson);
              if (data['phoneNumber'] == phoneNumber) {
                foundEmail = data['email'];
                break;
              }
            } catch (e) {
              debugPrint('Error parsing registration data: $e');
            }
          }
        }
      }
      
      if (foundEmail == null) {
        debugPrint('No email found for phone: $phoneNumber');
        debugPrint('Available registration data: ${_inMemoryPrefs.keys.toList()}');
        throw AuthException(AuthErrorCodes.userNotFound,
          details: 'Registration data not found. Please start signup again.');
      }
      if (_backendBaseUrl.isNotEmpty) {
        final uri = Uri.parse(_backendEndpoint('/api/verify-phone'));
        final res = await http.post(uri,
            headers: {'Content-Type': 'application/json'},
            body: jsonEncode({'phone': phoneNumber, 'otp': otp}));
        if (res.statusCode == 200) {
          final data = jsonDecode(res.body) as Map<String, dynamic>;
          final user = User.fromJson(data);
          await _saveUserToPrefs(user);
          return true;
        } else {
          throw AuthException(AuthErrorCodes.serverError,
              message: 'OTP verify failed: ${res.body}');
        }
      }

<<<<<<< HEAD
      debugPrint('Found email $foundEmail for phone $phoneNumber, verifying...');
      // Verify using email
      return verifyEmailOTP(email: foundEmail, otp: otp);
    } on AuthException {
=======
      debugPrint('Verifying OTP: $otp for phone: $phoneNumber');

      // Get temporary user
      final tempUserJson = _prefs.getString('temp_user_$phoneNumber');
      if (tempUserJson == null) {
        throw AuthException(AuthErrorCodes.userNotFound);
      }

      final user = User(
        email: '',
        phoneNumber: phoneNumber,
        phoneVerified: true,
        createdAt: DateTime.now(),
      );

      await _saveUserToPrefs(user);
      await _removeString('temp_user_$phoneNumber');

      return true;
    } catch (e) {
      debugPrint('OTP verification error: $e');
>>>>>>> origin/main
      rethrow;
    } catch (e) {
      debugPrint('Unexpected phone OTP verification error: $e');
      throw AuthException(AuthErrorCodes.serverError,
        details: 'Verification failed: ${e.toString()}');
    }
  }

  Future<bool> resendEmailOTP({required String email}) async {
    try {
      if (!_isValidEmail(email)) {
        throw AuthException(AuthErrorCodes.invalidEmail);
      }

      // Get registration data to resend OTP
      final registrationDataJson = await _getString('registration_data_$email');
      if (registrationDataJson != null) {
        final regData = _jsonDecode(registrationDataJson);
        
        // Resend OTP via backend API
        await _apiService.sendOtp(
          email: email,
          username: regData['username'],
          firstName: regData['firstName'],
          lastName: regData['lastName'],
          password: regData['password'],
          phoneNumber: regData['phoneNumber'],
          languagePreference: regData['preferredLanguage'],
        );
        
        debugPrint('OTP resent successfully to email: $email');
        return true;
      } else {
        throw AuthException(
          AuthErrorCodes.serverError,
          details: 'Registration data not found. Please start signup again.',
        );
      }
    } catch (e) {
      debugPrint('Resend OTP error: $e');
      rethrow;
    }
  }

  Future<bool> resendPhoneOTP({required String phoneNumber}) async {
    // Since we only verify email, find the email associated with this phone
    try {
      if (!_isValidPhoneNumber(phoneNumber)) {
        throw AuthException(AuthErrorCodes.invalidPhone);
      }

      // Find email from registration data
      String? foundEmail;
      final allKeys = _inMemoryPrefs.keys;
      for (final key in allKeys) {
        if (key.startsWith('registration_data_')) {
          final dataJson = _inMemoryPrefs[key];
          if (dataJson != null) {
            try {
              final data = _jsonDecode(dataJson);
              if (data['phoneNumber'] == phoneNumber) {
                foundEmail = data['email'];
                break;
              }
            } catch (e) {
              debugPrint('Error parsing registration data: $e');
            }
          }
        }
      }

      if (foundEmail != null) {
        return resendEmailOTP(email: foundEmail);
      } else {
        throw AuthException(
          AuthErrorCodes.serverError,
          details: 'Registration data not found. Please start signup again.',
        );
      }
    } catch (e) {
      debugPrint('Resend phone OTP error: $e');
      return false;
    }
  }

  Future<User?> updateUserProfile({
    required String userId,
    String? firstName,
    String? lastName,
    DateTime? dateOfBirth,
    String? gender,
    String? profileImagePath,
    String? preferredLanguage,
  }) async {
    try {
      if (_currentUser == null) {
        throw AuthException(AuthErrorCodes.noUserLoggedIn);
      }
      if (_backendBaseUrl.isNotEmpty) {
        final uri = Uri.parse(_backendEndpoint('/api/users/$userId'));
        final res = await http.put(uri,
            headers: {'Content-Type': 'application/json'},
            body: jsonEncode({
              'firstName': firstName,
              'lastName': lastName,
              'dateOfBirth': dateOfBirth?.toIso8601String(),
              'gender': gender,
              'profileImageUrl': profileImagePath,
            }));
        if (res.statusCode == 200) {
          final data = jsonDecode(res.body) as Map<String, dynamic>;
          final updated = User.fromJson(data);
          await _saveUserToPrefs(updated);
          return updated;
        } else {
          throw AuthException(AuthErrorCodes.serverError,
              message: 'Update failed: ${res.body}');
        }
      }

      final updatedUser = _currentUser!.copyWith(
        firstName: firstName,
        lastName: lastName,
        dateOfBirth: dateOfBirth,
        gender: gender,
        profileImageUrl: profileImagePath,
        preferredLanguage: preferredLanguage,
        updatedAt: DateTime.now(),
      );

      await _saveUserToPrefs(updatedUser);
      return updatedUser;
    } catch (e) {
      debugPrint('Update profile error: $e');
      rethrow;
    }
  }

  @override
  Future<User> signIn({
    required String email,
    required String password,
  }) async {
    try {
<<<<<<< HEAD
      // Login with email address
      await _apiService.login(
        email: email,
        password: password,
      );
      debugPrint('User logged in with email: $email');

      // Fetch full user details after login (prefer /user/get_user for complete registration data)
      final userData = await _apiService.getUser();
      final user = User.fromJson(userData);

      // Store user locally
      await _saveUserToPrefs(user);

      return user; // Guaranteed non-null on success
    } on ApiException catch (e) {
      debugPrint('API login error: ${e.message}');
      if (e.statusCode == 401 || e.message.toLowerCase().contains('credentials')) {
        throw AuthException(AuthErrorCodes.invalidCredentials);
      } else if (e.message.toLowerCase().contains('not found')) {
=======
      // In production, call backend authentication
      final userJson = _prefs.getString('user_$email');
      if (userJson == null) {
>>>>>>> origin/main
        throw AuthException(AuthErrorCodes.userNotFound);
      } else if (e.statusCode >= 500) {
        throw AuthException(AuthErrorCodes.serverError,
          details: 'The backend server is temporarily unavailable. This may be because the server is starting up (this can take up to 30 seconds). Please wait a moment and try again.');
      }
<<<<<<< HEAD
      throw AuthException(AuthErrorCodes.serverError, details: e.message);
    } on TimeoutException {
      throw AuthException(AuthErrorCodes.serverError,
        details: 'The server took too long to respond. It may be starting up. Please wait 30 seconds and try again.');
=======

      // Load and return user
      _loadUserFromPrefs();
      return _currentUser;
>>>>>>> origin/main
    } catch (e) {
      debugPrint('Sign in error: $e');
      rethrow; // Propagate errors; never return null
    }
  }

  Future<void> signOut() async {
    try {
      // Logout from API (may fail if token was already cleared)
      await _apiService.logout();
    } catch (e) {
      debugPrint('Logout failed during sign out (continuing): $e');
    } finally {
      _currentUser = null;
      _inMemoryPrefs.remove('user');
      _authStateController.add(null);
      notifyListeners();
      debugPrint('User signed out successfully');
    }
  }

  Future<User?> getCurrentUser() async {
    // If we have a token, fetch fresh user data from API
    final token = await _apiService.getStoredToken();
    if (token != null) {
      try {
        // Prefer the endpoint that returns registration-derived credentials
        final userData = await _apiService.getUser();
        final user = User.fromJson(userData);
        await _saveUserToPrefs(user);
        return user;
      } catch (e) {
        debugPrint('Error fetching current user from API: $e');
        // Return cached user if API call fails
        return _currentUser;
      }
    }
    return _currentUser;
  }

  Stream<User?> authStateChanges() {
    return _authStateController.stream;
  }

  bool _isValidEmail(String email) {
    final emailRegex = RegExp(
        r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$');
    return emailRegex.hasMatch(email);
  }

  bool _isValidPhoneNumber(String phone) {
    final digitsOnly = phone.replaceAll(RegExp(r'\D'), '');
    return digitsOnly.length >= 7 && digitsOnly.length <= 15;
  }

  @override
  void dispose() {
    _authStateController.close();
    super.dispose();
  }
}

// Backwards compatibility: alias old class name to new implementation
typedef AuthServiceImpl = AuthService;
